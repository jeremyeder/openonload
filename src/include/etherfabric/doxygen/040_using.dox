/****************************************************************************
 * Copyright 2004-2005: Level 5 Networks Inc.
 * Copyright 2005-2015: Solarflare Communications Inc,
 *                      7505 Irvine Center Drive, Suite 100
 *                      Irvine, CA 92618, USA
 *
 * Maintained by Solarflare Communications
 *  <linux-xen-drivers@solarflare.com>
 *  <onload-dev@solarflare.com>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation, incorporated herein by reference.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 ****************************************************************************
 */

/**************************************************************************\
*//*! \file
** \author    Solarflare Communications, Inc.
** \brief     Additional Doxygen-format documentation for ef_vi.
** \date      2015/02/14
** \copyright Copyright &copy; 2015 Solarflare Communications, Inc. All
**            rights reserved. Solarflare, OpenOnload and EnterpriseOnload
**            are trademarks of Solarflare Communications, Inc.
*//*
\**************************************************************************/

/**************************************************************************
 * Using ef_vi page
 *************************************************************************/
 /*! \page using Using %ef_vi

This part of the documenttaion gives information on using %ef_vi to write 
and build applications.

\section components Components

All components required to build and link a user application with the 
Solarflare %ef_vi API are distributed with Onload. When Onload is 
installed all required directories/files are located under the Onload 
distribution directory:

\section compiling Compiling and Linking

Refer to the `README.%ef_vi` file in the Onload directory for compile and 
link instructions.

\section using_setup Setup

Applications requiring specific features can check the versions of software:
- use ef_vi_version_str() to get the version of %ef_vi
- use ef_vi_driver_interface_str() to get the char driver interface 
  required by this build of %ef_vi.

Users of %ef_vi must do the following to setup:
-# Obtain a driver handle by calling ef_driver_open().
-# Allocate a protection domain by calling one of the following:
   - ef_pd_alloc()
   - ef_pd_alloc_by_name()
   - ef_pd_alloc_with_vport().
-# Allocate a virtual interface (VI), encapsulated by the type ef_vi, by
 calling ef_vi_alloc_from_pd().

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
/* Allocate a protection domain */
int ef_pd_alloc(ef_pd *pd,
                ef_driver_handle pd_dh,
                int ifindex,
                enum ef_pd_flags flags);

int ef_pd_alloc_by_name(ef_pd *pd,
                        ef_driver_handle pd_dh,
                        const char* cluster_or_intf_name,
                        enum ef_pd_flags flags);

/* Get the interface for a protection domain. */
const char* ef_pd_interface_name(ef_pd *pd);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
__Figure: Create a Protection Domain__

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
/* Allocate a virtual interface */
int ef_vi_alloc_from_pd(ef_vi *vi, ef_driver_handle vi_dh,
                        ef_pd *pd, ef_driver_handle pd_dh,
                        int eventq_cap, int rxq_cap, int txq_cap,
                        ef_vi *opt_evq, ef_driver_handle opt_evq_dh,
                        enum ef_vi_flags flags));
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
__Figure: Allocate a Virtual Interface__

\subsection using_vi_sets Using Virtual Interface Sets.

A virtual interface set can be used instead of a single virtual interface, 
to distribute load using RSS. Functionality is almost the same as working 
with a single virtual interface:
- To allocate the virtual interfaces:
  - use ef_vi_set_alloc_from_pd() to allocate the set
  - then use ef_vi_alloc_from_set() to allocate each virtual interface in 
    the set
- To add a filter:
  - use ef_vi_set_filter_add() to add the filter onto the set, rather than 
    adding it to each virtual interface individually (which would cause 
    replication on a 7000-series NIC).

The \ref efrss sample gives an example of usage.

\section using_buffers Creating packet buffers

Memory used for packet buffers is allocated using standard functions such 
as posix_memalign(). A packet buffer should be at least as large as the 
value returned from ef_vi_receive_buffer_len().

The packet buffers must be pinned so that they cannot be paged, and they 
must be registered for DMA with the network adapter. These requirements 
are enforced by calling ef_memreg_alloc() to register the allocated memory 
for use with %ef_vi.

The type `ef_iobufset` encapsulates a set of buffers. The adapter uses a 
special address space to identify locations in these buffers, and such 
addresses are designated by the type `ef_addr`.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
/* Allocate a memory region */
int ef_memreg_alloc(ef_memreg* mr, ef_driver_handle mr_dh,
                    ef_pd* pd, ef_driver_handle pd_dh,
                    void* p_mem, int len_bytes);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
__Figure: Allocate a Memory Region__

Performance will be improved when cache lined memory is set to a use a 
minimum 4KB or aligning the memory region on a 2MB boundary to use huge 
pages.

\section using_transmit Transmitting Packets

To transmit packets, the basic process is:

-# Write the packet contents (including all headers) into one or more 
   packet buffers.

   The packet buffer memory must have been previously registered with the 
   protection domain.

-# Post a descriptor for the filled packet buffer onto the TX descriptor 
   ring, by calling ef_vi_transmit_init() and ef_vitransmit_push(), or
   ef_vi_transmit().

   A doorbell is "rung" to inform the adapter that the transmit ring is
   non-empty. If the transmit descriptor ring is empty when the doorbell 
   is rung, 'TX PUSH' is used. In 'TX_PUSH', the doorbell is rung and the 
   address of the packet buffer is written in one shot improving latency. 
   TX_PUSH can cause %ef_vi to poll for events, to check if the transmit 
   descriptor ring is empty, before sending which can lead to a latency 
   versus throughput trade off in some scenarios.

-# Poll the event queue to find out when the transmission is complete.

   See \ref using_events.

   When transmitting, polling the event queue is less critical; but does 
   still need to be done. The events of interest are `EF_EVENT_TYPE_TX` or 
   `EF_EVENT_TYPE_TX_WITH_TIMESTAMP` telling you that a transmit 
   completed, and `EF_EVENT_TYPE_TX_ERROR` telling you that a transmit 
   failed. EF_EVENT_TX_Q_ID() can be used to extract the id of the 
   referenced packet, or you can just rely on the fact that %ef_vi always 
   transmits packets in the order they are submitted.

-# Handle the resulting event.

   Reclaim the packet buffer for re-use.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
// construct packet with proper headers

// Post on the transmit ring
ef_vi_transmit_init(&vi, addr, len, id);
// Ring doorbell
ef_vi_transmit_push(&vi);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
__Figure: Transmit Packets__

\subsection using_tx_jumbo Transmitting Jumbo Frames

Packets of a size smaller than the interface MTU but larger than the 
packet buffer size must be sent from multiple buffers as jumbo packets. A 
single `EF_EVENT_TYPE_TX` (or `EF_EVENT_TYPE_TX_ERROR`) event is raised 
for the entire transmit:

- Use ef_vi_transmitv() to chain together multiple segments with a higher
  total length.

- MTU is not enforced. If the transmit is to remain within MTU, the 
  application must check and enforce this.

- The segments must at least split along natural (4k packet) boundaries,
  but smaller segments can be used if desired..

\subsection using_pio Programmed I/O

Programmed IO is usable only on 7000-series cards, not on the older cards. 
It allows for faster transmit, especially of small packets, but the 
hardware resources available for it are limited.

For this reason, a PIO buffer must be explicitly allocated and associated 
with a virtual interface before use, by calling  ef_pio_link_vi().

Data is copied into the PIO buffer with ef_pio_memcpy().

When the PIO buffer is no longer required it should be unlinked by calling 
ef_pio_unlink_vi(), and then freed by calling ef_pio_free().

\section using_events Handling Events

The event queue is a channel from the adapter to software which notifies 
software when packets arrive from the network, and when transmits complete 
(so that the buffers can be freed or reused). Application threads retrieve 
these events in one of the following ways:
- A thread can busy-wait for an event notification by calling
  ef_eventq_poll() repeatedly in a tight loop. This gives the lowest
  latency.
- A thread can block until event notifications arrive (or a timeout
  expires) by calling ef_eventq_wait(). This frees the CPU for other usage.

The batch size for polling must be at least 8. It should be greater than 
the batch size for refilling to detect when the receive descriptor ring is 
going empty.

\subsection fd_blocking Blocking on a file descriptor

Ef_vi supports integration with other types of I/O via the select, poll 
and epoll interfaces. Each virtual interface is associated with a file 
descriptor. The %ef_vi layer supports blocking on a file descriptor until 
it has events ready, when it becomes readable.  This feature provides the 
functionality that is already provided by ef_eventq_wait() with the added 
benefit that as you are blocking on a file descriptor, you can block for 
events on a virtual interface along with other file descriptors at the 
same time.

The file descriptor to use for blocking is the driver handle that was used 
to allocate the virtual interface.

Before you can block on the file descriptor, you need to prime interrupts 
on the virtual interface. This is done by calling ef_vi_prime().

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
int ef_vi_prime(ef_vi* vi, ef_driver_handle dh,
                unsigned current_ptr);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When this function is called, you must tell it how many events you've read 
from the eventq which can be retrieved by using ef_eventq_current().  Then 
you can simply block on the file descriptor becoming readable by using 
select(), poll(), epoll(), etc.  When the file descriptor is returned as 
reablable, you can then get the associated events by polling the eventq in 
the normal way.  Note that at this point, you must call ef_vi_prime() 
again (with the current value from ef_eventq_current()) before blocking on 
the file descriptor again.

The efpingpong example code has been updated to offer a simple example.

\section using_receive Receiving packets

To receive packets, the basic process is:

-# Post descriptors for empty packet buffers onto the RX descriptor ring, 
   by calling ef_vi_receive_init() and ef_vi_receive_push(), or
   ef_vi_receive_post().

   Receive descriptors should be posted in multiples of 8. When an 
   application pushes 10 descriptors, %ef_vi will push 8 and %ef_vi will 
   ignore descriptor batch sizes < 8. Users should beware that if the ring 
   is empty and the application pushes < 8 descriptors before blocking on 
   the event queue, the application will remain blocked as there are no 
   descriptors available to receive packets so nothing gets posted to the 
   event queue.

   Posting descriptors is relatively slow. It should ideally be done in
   batches, by a thread that is not on the critical path. A small batch size
   means that the ring is kept more full, but a large batch size is more
   efficient. A size of 8, 16 or 32 is probably the best compromise.

-# Poll the event queue to see that they are now filled.

   See \ref using_events.

   Packets are written into the buffers in FIFO order.

-# Handle the resulting event and the incoming packet.

   Since the adapter is cut-through, errors in receiving packets like 
   multicast mismatch, CRC errors, etc. are delivered along with the 
   packet. The software must detect these errors and recycle the 
   associated packet buffers.

\subsection packet_data Finding the Packet Data

- If you're using the ef_sfw wrapper, then RX_PKT_PTR() returns a pointer
  to the start of the payload of the packet. (Remember that this includes
  the headers, as %ef_vi does not do any protocol handling.)

- Otherwise, you'll need to create similar functionality yourself. Use the
  queue ID to find the packet, and ef_vi_receive_prefix_len() to find the
  offset for the packet data.

\subsection using_rx_jumbo Receiving Jumbo Packets

Packets of a size smaller than the interface MTU but larger than the 
packet buffer size are delivered in multiple buffers as jumbo packets. An 
event is raised for each packet buffer that is filled:

- The EF_EVENT_RX_CONT() macro can be used to check if this is not the 
  last part of the packet, and that the next receive (on this RX descriptor 
  ring) should also be examined as being part of this jumbo frame.

- The length given in each event is the total length of the packet so far
  (so the length in the last part of the frame is the total packet length.)

- If `EF_EVENT_RX_DISCARD_TRUNC` is set, this indicates that the packet
  buffer has been dropped, and sothe jumbo packet has been truncated. But
  there might still be more parts of the jumbo packet that arrive after
  the drop. All packet buffers should be discarded until one is received
  with `EF_EVENT_RX_SOP` set, marking the start of a new packet.

\section using_filters Adding Filters

Filters are the means by which the adapter decides where to deliver 
packets it receives from the network. By default all packets are delivered 
to the kernel network stack. Filters are added by an %ef_vi application to 
direct received packets to a given virtual interface.

- If a filter cannot be added, for example because an incompatible filter
  already exists, an error is returned.

- By default the 'all' filters are sending everything to the kernel. They
  are equivalent to setting promiscuous mode on the NIC, and super-user
  rights (specifically `CAP_NET_ADMIN`) are needed to use this filters.

- On 5000-series and 6000-series NICs each filter can only exist for one
  virtual interface, and so each packet which arrives can be forwarded
  only to a single application (unless two applications share a stack).
  Only the first application to insert a specific filter will succeed;
  other applications will then get an error.

  Note that this includes filters inserted both by other %ef_vi 
  applications and by Onload - which typically uses only fully connected 
  and listen filters.

- The 7xxx series of NICs lifts this restriction. If two applications 
  insert the same filter, they will each be delivered a copy of the packet 
  and remain unaware of the other.

- IP filters do not match IP fragments, which are therefore received by
  the kernel stack. If this is an issue, layer 2 filters should be
  installed by the user.

- There are no ranges, or other local wildcard support. To filter on a
  range of values, one of the following is required:

  - insert multiple filters, one per value in the range  (NICs support
    upwards of a thousand filters easily)

  - have the interesting traffic sent to a specific MAC address, and use a
    MAC address filter

  - have the interesting traffic sent to a specific VLAN, and use a VLAN
    filter.

- Cookies are used to remove filters.

- De-allocating a virtual interface removes any filters set for the
  virtual interface.

Filters are checked in the following order, which is roughly most-specific
first:
-# Fully connected TCP/UDP. (Specifies local and remote port and IP)
-# Listen socket. (Specifies local port and IP, but allows any remote
   IP/port)
-# Destination MAC address, and optionally VLAN. (Useful for multicast
   reception, though IP can be used instead if preferred. Also useful for
   custom protocols.)
-# Everything else. (All unicast, all multicast.)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
void ef_filter_spec_init(ef_filter_spec* fs,
                         enum ef_filter_flags flags);

int ef_filter_spec_set_ip4_local(ef_filter_spec* fs,
                                 int protocol,
                                 unsigned host_be32, int port_be16);

int ef_filter_spec_set_ip4_full(ef_filter_spec* fs,
                                int protocol,
                                unsigned host_be32, int port_be16,
                                unsigned rhost_be32, int rport_be16);

int ef_filter_spec_set_vlan(ef_filter_spec* fs,
                            int vlan_id);

int ef_filter_spec_set_eth_local(ef_filter_spec* fs,
                                 int vlan_id,
                                 const void *mac);

int ef_filter_spec_set_unicast_all(ef_filter_spec* fs);

int ef_filter_spec_set_multicast_all(ef_filter_spec* fs);

int ef_filter_spec_set_unicast_mismatch(ef_filter_spec* fs);

int ef_filter_spec_set_multicast_mismatch(ef_filter_spec* fs);

int ef_filter_spec_set_port_sniff(ef_filter_spec* fs,
                                  int promiscuous);

int ef_filter_spec_set_tx_port_sniff(ef_filter_spec* fs);

int ef_filter_spec_set_block_kernel(ef_filter_spec* fs);

int ef_filter_spec_set_block_kernel_multicast(ef_filter_spec* fs);

int ef_filter_spec_set_block_kernel_unicast(ef_filter_spec* fs);

int ef_vi_filter_add(ef_vi* vi,ef_driver_handle dh,
                     const ef_filter_spec* fs,
                     ef_filter_cookie* filter_cookie_out);

int ef_vi_filter_del(ef_vi* vi, ef_driver_handle dh,
                     ef_filter_cookie* filter_cookie);

int ef_vi_set_filter_add(ef_vi_set*,
                        ef_driver_handle dh,
                        const ef_filter_spec* fs,
                        ef_filter_cookie* filter_cookie_out);

int ef_vi_set_filter_del(ef_vi_set*, ef_driver_handle dh,
                         ef_filter_cookie* filter_cookie);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
__Figure: Creating Filters__

\section using_freeing Freeing Resources

Users of %ef_vi must do the following to free resources:
-# Release and free memory regions by calling ef_memreg_free().
-# Release and free a virtual interface by calling ef_vi_free().
-# Release and free a protection domain by calling ef_pd_free().
-# Close a driver handle by calling ef_driver_close().

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
/* Release and free a memory region */
int ef_memreg_free(ef_memreg* mr,
                   ef_driver_handle mr_dh);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
__Figure: Release and Free a Memory Region__

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
/* Release and free a virtual interface */
int ef_vi_free(ef_vi* vi,
               ef_driver_handle vi_dh);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
__Figure: Release and Free a Virtual Interface__

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
/* Release and free a protection domain */
int ef_pd_free(ef_pd *pd,
               ef_driver_handle pd_dh);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
__Figure: Release and Free a Protection Domain__

\section design Design Considerations

This section outlines some considerations that are required when designing 
an %ef_vi application.

\subsection interrupts Interrupts

Interrupts are not enabled by %ef_vi by default.

Interrupts are enabled only if ef_eventq_wait() is called. If there are no 
events immediately ready, then this function will enable an interrupt, and 
sleep until that interrupt fires. Interrupts are then disabled again.

\subsection thread_safety Thread Safety

There is no thread-safety on %ef_vi functions. This is for speed. If 
thread-safety is required, it must be provided by the %ef_vi application.

The usual use-case is to have multiple virtual interface structures for 
independent operation. There is then no need to lock.

\subsection pb_addressing Packet Buffer Addressing

Different configuration modes are available for addressing packet buffers.

- _Network Adapter Buffer Table Mode_ uses a block of memory on the 
  adapter to store a translation table mapping between buffer IDs and 
  physical addresses:

  - When using a SFN5000 or SFN6000 series adapter there are 65536 entries
    in the buffer table. Each entry maps a 4KB page of memory that holds
	two 2KB packet buffers, and so a maxiumum of 131072 packet buffers are
	available. The kernel usues some of these, leaving about 120,000
	packet buffers available for %ef_vi.

  - The SFN7000 series adapters have _Large Buffer Table Support_. Each
    entry can map a larger region of memory, or a huge page, enabling them
	to support many more packet buffers without the need to use Scalable
	Packet Buffer Mode.

  This is the default mode.

- _Scalable Packet Buffer Mode_ allocates packet buffers from the kernel
  IOMMU. It uses Single Root I/O Virtualization (SR-IOV) virtual functions
  (VF) to provide memory protection and translation. This removes the
  buffer limitation of the buffer table.

  - SR-IOV must be enabled

  - the kernel must support an IOMMU.

  An %ef_vi application can enable this mode by setting the environment
  variable `EF_VI_PD_FLAGS=vf`.

- _Physical Addressing Mode_ uses actual physical addresses to identify
  packet buffers. An %ef_vi application can therefore direct the adapter
  to access memory that is not in the application address space. For
  example, this can be used for zero-copy from the kernel buffer cache.
  any piece of memory.

  - No memory protection is provided.

  - It is important to ensure that packet buffers are page aligned.

  An %ef_vi application can enable this mode by setting the environment
  variable `EF_VI_PD_FLAGS=phys`.

For more information about these configuration modes, see the chapter 
titled _Packet Buffers_ in the _Onload User Guide_ (SF-104474-CD).

\subsection vm Virtual machines

Ef_vi can be used in virtual machines provided PCI passthrough is used. 
With PCI passthrough a slice of the network adapter is mapped directly 
into the address space of the virtual machine so that device drivers in 
the VM OS can access the network adapter directly. To isolate VMs from one 
another and from the hypervisor, I/O addresses are also virtualised. I/O 
addresses generated by the network adapter are translated to physical 
memory addresses by the system IOMMU.

When %ef_vi is used in virtual machines two levels of address translation 
are performed by default. Firstly a translation from DMA address to I/O 
address, performed by the adapter to isolate the application from other 
applications and the kernel. Then a translation from I/O address to 
physical address by the system IOMMU, isolating the virtual machines. 
Physical address mode can also be used in virtual machines, in which case 
the adapter translation is omitted.

\section limitations Known Limitations

\subsection timestamping Timestamping

If timestamping is enabled, then the VI must be polled regularly (even if 
no packets are available). Failing to do so can lead to an event queue 
overflow as the time-synchronization mechanism will not be being 
processed. Although these events are not returned to the application, they 
do need to be cleared from the queue.

\subsection fill_level Minimum Fill Level

You must poll for at least EF_VI_EVENT_POLL_MIN_EVS at a time. You will 
also need to initially fill the RX ring with at least 16 packet buffers to 
ensure that the card begins acquiring packets. (It's OK to underrun once 
the application has started; although of course doing so risks drops.)

It's (very slightly) more efficient to refill the ring in batch sizes of 
8/16/32 or 64 anyway.

\section using_example Example

Below is a simple example showing a starting framework for an %ef_vi 
application. This is not a complete program. There is no initialization, 
anmd much of the other required code is only indicated by comments.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
static void handle_poll(ef_vi *vi)
{
  ef_event events[POLL_BATCH_SIZE];
  int n_ev = ef_eventq_poll(&vi, events, POLL_BATCH_SIZE);
  for( i = O; i < n_ev; ++i ) {
    switch( EF_EVENT_TYPE(events[i]) ) {
    case EF_EVENT_TYPE_RX:
      // Accumulate used buffer
      break;
    case EF_EVENT_TYPE_TX:
      /* Each EF_EVENT_TYPE_TX can signal multiple completed sends */
      int num_completed = ef_vi_transmit_unbundle(vi, events[i], &dma_id);
      break;
    case EF_EVENT_TYPE_RX_DISCARD:
    case EF_EVENT_TYPE_RX_NO_DESC_TRUNC:
      /* Discard events also use up buffers */
      // Accumulate buffer in user space
      break;
    default:
      /* Other error types */
    }
  }
}

static void refill_rx_ring(ef_vi *vi)
{
  if( ef_vi_receive_space(&vi) < REFILL_BATCH_SIZE )
    return;
  int refill_count = REFILL_BATCH_SIZE;
  /* Falling too low? */
  if( ef_vi_receive_space(&vi) > ef_vi_receive_capacity(&vi) / 2 )
    refill_count = ef_vi_receive_space(&vi);
  /* Enough free buffers? */
  if( refill_count > free_bufs_in_sw )
    refill_count = free_bufs_in_sw;
  /* Round down to batch size */
  refill_count &= ~(REFILL_BATCH_SIZE - 1);
  if( refill_count ) {
    while( refill_count ) {
      ef_vi_receive_init(...);
      --refill_count;
	}
    ef_vi_receive_push(&vi);
  }
}

int main(int argc, char argv[]) (
  while( 1 ) {
    poll_events(&vi);
    refill_rx_ring(&vi);
  }
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*/