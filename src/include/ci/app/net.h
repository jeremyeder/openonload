/*
** Copyright 2005-2012  Solarflare Communications Inc.
**                      7505 Irvine Center Drive, Irvine, CA 92618, USA
** Copyright 2002-2005  Level 5 Networks Inc.
**
** This program is free software; you can redistribute it and/or modify it
** under the terms of version 2 of the GNU General Public License as
** published by the Free Software Foundation.
**
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU General Public License for more details.
*/

/**************************************************************************\
*//*! \file
** <L5_PRIVATE L5_HEADER>
** \author  
**  \brief  
**   \date  
**    \cop  (c) Level 5 Networks Limited.
** </L5_PRIVATE>
*//*
\**************************************************************************/

/*! \cidoxg_include_ci_app */
#ifndef __CI_APP_NET_H__
#define __CI_APP_NET_H__

# include <arpa/inet.h>
# include <netinet/in.h>
# include <sys/types.h>
# include <sys/socket.h>
# include <netdb.h>


/**********************************************************************
 ** CI typechecked socket error codes.
 */
typedef struct { int val; } ci_sock_err_t;

/* All socket related errors which are used or generated by CI libraries. Other
   system generated socket errors may be passed through suitably wrapped */
extern ci_sock_err_t  CI_SOCK_OK;
extern ci_sock_err_t  CI_SOCK_INVALID;
extern ci_sock_err_t  CI_SOCK_EWOULDBLOCK;
extern ci_sock_err_t  CI_SOCK_EMSGSIZE;
extern ci_sock_err_t  CI_SOCK_ETIMEDOUT;
extern ci_sock_err_t  CI_SOCK_ECONNREFUSED;
extern ci_sock_err_t  CI_SOCK_ECONNABORTED;
extern ci_sock_err_t  CI_SOCK_EOPNOTSUPP;
extern ci_sock_err_t  CI_SOCK_ENOBUFS;

ci_inline ci_sock_err_t 
ci_sock_err(int val)		/*!< construct sock_err from errno */
{
  ci_sock_err_t e;
  e.val = val;
  return e;
}

ci_inline int
ci_sock_iserrno(ci_sock_err_t e) /*!< test whether system errno matches */
{
  return (e.val == CI_SOCK_ERRNO());  /*! \TODO rename these macros */
}

/*! Comment? */
ci_inline int
ci_sock_errok(ci_sock_err_t e) { return (e.val == CI_SOCK_OK.val); }

/*! Comment? */
ci_inline int
ci_sock_erreq(ci_sock_err_t a, ci_sock_err_t b) { return (a.val == b.val); }

/*! Comment? */
ci_inline int
ci_sock_errcode(ci_sock_err_t a) { return -a.val; }


/**********************************************************************
 ** Useful helpers (not error checked).
 */

  /*! Parse [hp], which must be in the format: <host>, <port> or
  ** <host:port>.  Returns 0 on success, or negative error code on failure.
  */
extern int ci_hostport_to_sockaddr(const char* hp,
				   struct sockaddr_in* addr_out);

  /*! Convert hostname and port to sockaddr.  [host] may be null, in which
  ** case INADDR_ANY is used.  Returns 0 on success, or negative error code
  ** on failure.
  */
extern int ci_host_port_to_sockaddr(const char* host, int port,
				    struct sockaddr_in* addr_out);

  /*! Like inet_ntoa(), but puts the result in the given buffer (which
  ** should be at least 16 bytes long).  Returns the number of bytes
  ** written.
  */
extern int ci_ntoa(struct in_addr in, char* buf);

  /*! Set blocking mode for [fd]. */
extern int ci_setfdblocking(int fd, int blocking);


#endif  /* __CI_APP_NET_H__ */

/*! \cidoxg_end */
